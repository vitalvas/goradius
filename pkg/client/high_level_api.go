package client

import (
	"context"
	"fmt"
	"time"

	"github.com/vitalvas/goradius/pkg/log"
	"github.com/vitalvas/goradius/pkg/packet"
)

// HighLevelClient provides simplified, high-level APIs for common RADIUS operations
type HighLevelClient struct {
	client Client
	logger log.Logger
}

// NewHighLevelClient creates a new high-level client wrapper
func NewHighLevelClient(client Client, logger log.Logger) *HighLevelClient {
	if logger == nil {
		logger = log.NewDefaultLogger()
	}

	return &HighLevelClient{
		client: client,
		logger: logger,
	}
}

// RequestBuilder provides a fluent interface for building RADIUS requests
type RequestBuilder struct {
	packet  *packet.Packet
	client  *HighLevelClient
	timeout time.Duration
	retries int
}

// NewRequest creates a new request builder
func (hlc *HighLevelClient) NewRequest(code packet.Code) *RequestBuilder {
	return &RequestBuilder{
		packet:  packet.New(code, 0), // ID will be generated by client
		client:  hlc,
		timeout: 30 * time.Second,
		retries: 3,
	}
}

// WithTimeout sets the request timeout
func (rb *RequestBuilder) WithTimeout(timeout time.Duration) *RequestBuilder {
	rb.timeout = timeout
	return rb
}

// WithRetries sets the number of retry attempts
func (rb *RequestBuilder) WithRetries(retries int) *RequestBuilder {
	rb.retries = retries
	return rb
}

// WithAttribute adds an attribute to the request
func (rb *RequestBuilder) WithAttribute(attrType uint8, value interface{}) *RequestBuilder {
	attr := packet.Attribute{
		Type: attrType,
	}

	// Convert value to appropriate byte representation
	switch v := value.(type) {
	case string:
		attr.Value = []byte(v)
	case []byte:
		attr.Value = v
	case uint32:
		attr.Value = packet.EncodeUint32(v)
	case uint64:
		attr.Value = packet.EncodeUint64(v)
	case int:
		attr.Value = packet.EncodeUint32(uint32(v))
	case time.Time:
		attr.Value = packet.EncodeTime(v)
	default:
		// Try to convert to string as fallback
		attr.Value = []byte(fmt.Sprintf("%v", v))
	}

	rb.packet.Attributes = append(rb.packet.Attributes, attr)
	return rb
}

// WithStringAttribute adds a string attribute
func (rb *RequestBuilder) WithStringAttribute(attrType uint8, value string) *RequestBuilder {
	return rb.WithAttribute(attrType, value)
}

// WithIntegerAttribute adds an integer attribute
func (rb *RequestBuilder) WithIntegerAttribute(attrType uint8, value uint32) *RequestBuilder {
	return rb.WithAttribute(attrType, value)
}

// WithIPAttribute adds an IP address attribute
func (rb *RequestBuilder) WithIPAttribute(attrType uint8, ip string) *RequestBuilder {
	return rb.WithAttribute(attrType, packet.EncodeIPAddress(ip))
}

// WithUserName adds User-Name attribute
func (rb *RequestBuilder) WithUserName(username string) *RequestBuilder {
	return rb.WithStringAttribute(packet.AttrUserName, username)
}

// WithPassword adds User-Password attribute (authentication not supported)
func (rb *RequestBuilder) WithPassword(password string) *RequestBuilder {
	// Note: Authentication is no longer supported, but we still allow the attribute
	// to be added for compatibility. However, it won't be encrypted.
	return rb.WithStringAttribute(packet.AttrUserPassword, password)
}

// WithNASIPAddress adds NAS-IP-Address attribute
func (rb *RequestBuilder) WithNASIPAddress(ip string) *RequestBuilder {
	return rb.WithIPAttribute(packet.AttrNASIPAddress, ip)
}

// WithNASPort adds NAS-Port attribute
func (rb *RequestBuilder) WithNASPort(port uint32) *RequestBuilder {
	return rb.WithIntegerAttribute(packet.AttrNASPort, port)
}

// WithCallingStationID adds Calling-Station-Id attribute
func (rb *RequestBuilder) WithCallingStationID(stationID string) *RequestBuilder {
	return rb.WithStringAttribute(packet.AttrCallingStationID, stationID)
}

// WithCalledStationID adds Called-Station-Id attribute
func (rb *RequestBuilder) WithCalledStationID(stationID string) *RequestBuilder {
	return rb.WithStringAttribute(packet.AttrCalledStationID, stationID)
}

// WithNASIdentifier adds NAS-Identifier attribute
func (rb *RequestBuilder) WithNASIdentifier(identifier string) *RequestBuilder {
	return rb.WithStringAttribute(packet.AttrNASIdentifier, identifier)
}

// Send executes the request
func (rb *RequestBuilder) Send(ctx context.Context) (*packet.Packet, error) {
	// Create context with timeout
	timeoutCtx, cancel := context.WithTimeout(ctx, rb.timeout)
	defer cancel()

	// Send request with retries
	response, err := rb.client.client.SendRequestWithRetry(timeoutCtx, rb.packet, rb.retries)
	if err != nil {
		rb.client.logger.Errorf("Failed to send RADIUS request: %v", err)
		return nil, err
	}

	rb.client.logger.Debugf("RADIUS request sent successfully, response code: %d", response.Code)
	return response, nil
}

// ResponseHelper provides helper methods for working with responses
type ResponseHelper struct {
	packet *packet.Packet
	logger log.Logger
}

// NewResponseHelper creates a new response helper
func (hlc *HighLevelClient) NewResponseHelper(response *packet.Packet) *ResponseHelper {
	return &ResponseHelper{
		packet: response,
		logger: hlc.logger,
	}
}

// IsSuccess checks if the response indicates success
func (rh *ResponseHelper) IsSuccess() bool {
	return rh.packet.Code == packet.CodeAccessAccept
}

// IsFailure checks if the response indicates failure
func (rh *ResponseHelper) IsFailure() bool {
	return rh.packet.Code == packet.CodeAccessReject
}

// IsChallenge checks if the response is a challenge
func (rh *ResponseHelper) IsChallenge() bool {
	return rh.packet.Code == packet.CodeAccessChallenge
}

// GetStringAttribute retrieves a string attribute value
func (rh *ResponseHelper) GetStringAttribute(attrType uint8) (string, bool) {
	for _, attr := range rh.packet.Attributes {
		if attr.Type == attrType {
			return string(attr.Value), true
		}
	}
	return "", false
}

// GetIntegerAttribute retrieves an integer attribute value
func (rh *ResponseHelper) GetIntegerAttribute(attrType uint8) (uint32, bool) {
	for _, attr := range rh.packet.Attributes {
		if attr.Type == attrType && len(attr.Value) == 4 {
			return packet.DecodeUint32(attr.Value), true
		}
	}
	return 0, false
}

// GetIPAttribute retrieves an IP address attribute value
func (rh *ResponseHelper) GetIPAttribute(attrType uint8) (string, bool) {
	for _, attr := range rh.packet.Attributes {
		if attr.Type == attrType && len(attr.Value) == 4 {
			return packet.DecodeIPAddress(attr.Value), true
		}
	}
	return "", false
}

// GetReplyMessage retrieves the Reply-Message attribute
func (rh *ResponseHelper) GetReplyMessage() (string, bool) {
	return rh.GetStringAttribute(packet.AttrReplyMessage)
}

// GetFramedIPAddress retrieves the Framed-IP-Address attribute
func (rh *ResponseHelper) GetFramedIPAddress() (string, bool) {
	return rh.GetIPAttribute(packet.AttrFramedIPAddress)
}

// GetFramedNetmask retrieves the Framed-Netmask attribute
func (rh *ResponseHelper) GetFramedNetmask() (string, bool) {
	return rh.GetIPAttribute(packet.AttrFramedIPNetmask)
}

// GetSessionTimeout retrieves the Session-Timeout attribute
func (rh *ResponseHelper) GetSessionTimeout() (uint32, bool) {
	return rh.GetIntegerAttribute(packet.AttrSessionTimeout)
}

// GetIdleTimeout retrieves the Idle-Timeout attribute
func (rh *ResponseHelper) GetIdleTimeout() (uint32, bool) {
	return rh.GetIntegerAttribute(packet.AttrIdleTimeout)
}

// GetAllAttributes returns all attributes in the response
func (rh *ResponseHelper) GetAllAttributes() []packet.Attribute {
	return rh.packet.Attributes
}

// GetAttributesByType returns all attributes of a specific type
func (rh *ResponseHelper) GetAttributesByType(attrType uint8) []packet.Attribute {
	var result []packet.Attribute
	for _, attr := range rh.packet.Attributes {
		if attr.Type == attrType {
			result = append(result, attr)
		}
	}
	return result
}

// BatchRequest allows sending multiple requests efficiently
type BatchRequest struct {
	client   *HighLevelClient
	requests []*RequestBuilder
	timeout  time.Duration
}

// NewBatchRequest creates a new batch request
func (hlc *HighLevelClient) NewBatchRequest() *BatchRequest {
	return &BatchRequest{
		client:  hlc,
		timeout: 30 * time.Second,
	}
}

// Add adds a request to the batch
func (br *BatchRequest) Add(request *RequestBuilder) *BatchRequest {
	br.requests = append(br.requests, request)
	return br
}

// WithTimeout sets the timeout for the entire batch
func (br *BatchRequest) WithTimeout(timeout time.Duration) *BatchRequest {
	br.timeout = timeout
	return br
}

// BatchResponse represents the result of a batch request
type BatchResponse struct {
	Responses []*packet.Packet
	Errors    []error
	Success   int
	Failed    int
}

// Send executes all requests in the batch concurrently
func (br *BatchRequest) Send(ctx context.Context) (*BatchResponse, error) {
	if len(br.requests) == 0 {
		return &BatchResponse{}, nil
	}

	// Create context with timeout
	timeoutCtx, cancel := context.WithTimeout(ctx, br.timeout)
	defer cancel()

	// Create channels for results
	type result struct {
		response *packet.Packet
		err      error
		index    int
	}

	resultChan := make(chan result, len(br.requests))

	// Launch goroutines for each request
	for i, request := range br.requests {
		go func(idx int, req *RequestBuilder) {
			response, err := req.Send(timeoutCtx)
			resultChan <- result{
				response: response,
				err:      err,
				index:    idx,
			}
		}(i, request)
	}

	// Collect results
	batchResponse := &BatchResponse{
		Responses: make([]*packet.Packet, len(br.requests)),
		Errors:    make([]error, len(br.requests)),
	}

	for i := 0; i < len(br.requests); i++ {
		select {
		case res := <-resultChan:
			batchResponse.Responses[res.index] = res.response
			batchResponse.Errors[res.index] = res.err
			if res.err == nil {
				batchResponse.Success++
			} else {
				batchResponse.Failed++
			}
		case <-timeoutCtx.Done():
			// Handle timeout
			remaining := len(br.requests) - i
			batchResponse.Failed += remaining
			for j := i; j < len(br.requests); j++ {
				batchResponse.Errors[j] = timeoutCtx.Err()
			}
			return batchResponse, timeoutCtx.Err()
		}
	}

	return batchResponse, nil
}

// GetClient returns the underlying client
func (hlc *HighLevelClient) GetClient() Client {
	return hlc.client
}

// GetStatistics returns client statistics
func (hlc *HighLevelClient) GetStatistics() *Statistics {
	return hlc.client.GetStatistics()
}

// Close closes the underlying client
func (hlc *HighLevelClient) Close() error {
	return hlc.client.Close()
}
